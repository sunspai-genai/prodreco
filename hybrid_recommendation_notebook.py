{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Hybrid Wide & Deep Product Recommendation System\n",
    "## Business Banking - Deposits and Loans\n",
    "\n",
    "---\n",
    "\n",
    "**Complete End-to-End Pipeline**\n",
    "\n",
    "This notebook implements a production-grade recommendation system with:\n",
    "- ✅ Hybrid architecture (separate models for deposits and loans)\n",
    "- ✅ Severe imbalance handling (8.5% loan customers)\n",
    "- ✅ Stratified train/test split\n",
    "- ✅ Hyperparameter tuning\n",
    "- ✅ Comprehensive evaluation metrics\n",
    "- ✅ Top-N product ranking\n",
    "- ✅ SHAP explainability (global and local)\n",
    "\n",
    "**Dataset**: 355K customers | 80+ features | 15 products (5 deposits + 10 loans)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 0. Setup and Installation"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Install required packages (run once)\n",
    "!pip install numpy pandas scikit-learn tensorflow keras matplotlib seaborn shap joblib pyyaml loguru imbalanced-learn tqdm -q"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Import libraries\n",
    "import numpy as np\n",
    "import pandas as pd\n",
    "import matplotlib.pyplot as plt\n",
    "import seaborn as sns\n",
    "import warnings\n",
    "from pathlib import Path\n",
    "import json\n",
    "from typing import Dict, List, Tuple, Any\n",
    "from tqdm.notebook import tqdm\n",
    "\n",
    "# Deep Learning\n",
    "import tensorflow as tf\n",
    "from tensorflow import keras\n",
    "from tensorflow.keras import layers, Model\n",
    "from tensorflow.keras.callbacks import EarlyStopping, ReduceLROnPlateau, ModelCheckpoint\n",
    "\n",
    "# Preprocessing\n",
    "from sklearn.model_selection import train_test_split\n",
    "from sklearn.preprocessing import StandardScaler, LabelEncoder\n",
    "from sklearn.metrics import (\n",
    "    roc_auc_score, precision_recall_fscore_support, average_precision_score,\n",
    "    hamming_loss, jaccard_score, classification_report\n",
    ")\n",
    "\n",
    "# Imbalance handling\n",
    "from imblearn.over_sampling import SMOTE\n",
    "from imblearn.under_sampling import RandomUnderSampler\n",
    "\n",
    "# Explainability\n",
    "import shap\n",
    "\n",
    "# Utilities\n",
    "import joblib\n",
    "\n",
    "# Settings\n",
    "warnings.filterwarnings('ignore')\n",
    "plt.style.use('seaborn-v0_8-darkgrid')\n",
    "sns.set_palette('husl')\n",
    "\n",
    "# Set random seeds\n",
    "np.random.seed(42)\n",
    "tf.random.set_seed(42)\n",
    "\n",
    "print(\"✓ All imports successful\")\n",
    "print(f\"TensorFlow version: {tf.__version__}\")\n",
    "print(f\"GPU Available: {len(tf.config.list_physical_devices('GPU')) > 0}\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 1. Configuration"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Configuration Dictionary\n",
    "CONFIG = {\n",
    "    'data': {\n",
    "        'total_customers': 50000,  # Use 50K for notebook (faster), increase to 355K for production\n",
    "        'loan_customer_ratio': 0.085,\n",
    "        'random_seed': 42,\n",
    "        'test_size': 0.15,\n",
    "        'val_size': 0.15\n",
    "    },\n",
    "    'products': {\n",
    "        'deposits': ['Checking', 'Savings', 'MMA', 'CD_1Year', 'CD_GT1Year'],\n",
    "        'loans': [\n",
    "            'Term_Loan', 'Letter_of_Credit', 'Line_of_Credit',\n",
    "            'Term_Loan_Equipment', 'Term_Loan_Real_Estate', 'Business_Cards',\n",
    "            'Working_Capital_Loan', 'SBA_Loan', 'Construction_Loan', 'Bridge_Loan'\n",
    "        ]\n",
    "    },\n",
    "    'model': {\n",
    "        'wide_dim': 64,\n",
    "        'deep_dims': [256, 128, 64],\n",
    "        'dropout_rate': 0.4,\n",
    "        'l2_reg': 0.001\n",
    "    },\n",
    "    'training': {\n",
    "        'deposit': {\n",
    "            'epochs': 30,  # Reduced for notebook\n",
    "            'batch_size': 256,\n",
    "            'learning_rate': 0.001,\n",
    "            'early_stopping_patience': 10,\n",
    "            'strategy': 'balanced'\n",
    "        },\n",
    "        'loan': {\n",
    "            'epochs': 40,  # Reduced for notebook\n",
    "            'batch_size': 128,\n",
    "            'learning_rate': 0.0005,\n",
    "            'early_stopping_patience': 15,\n",
    "            'strategy': 'smote',\n",
    "            'positive_class_weight': 10.0,\n",
    "            'smote_sampling_ratio': 0.5\n",
    "        }\n",
    "    },\n",
    "    'hyperparameter_tuning': {\n",
    "        'enabled': False,  # Set to True for full tuning (slower)\n",
    "        'n_trials': 6\n",
    "    },\n",
    "    'recommendations': {\n",
    "        'top_n': 5,\n",
    "        'min_score': 0.3\n",
    "    },\n",
    "    'explainability': {\n",
    "        'shap_sample_size': 100,\n",
    "        'background_sample_size': 50,\n",
    "        'top_features': 15\n",
    "    }\n",
    "}\n",
    "\n",
    "print(\"✓ Configuration loaded\")\n",
    "print(f\"Dataset size: {CONFIG['data']['total_customers']:,} customers\")\n",
    "print(f\"Products: {len(CONFIG['products']['deposits'])} deposits + {len(CONFIG['products']['loans'])} loans\")\n",
    "print(f\"Hyperparameter tuning: {'Enabled' if CONFIG['hyperparameter_tuning']['enabled'] else 'Disabled'}\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 2. Data Generation\n",
    "\n",
    "Generate realistic banking data with:\n",
    "- 80+ customer features (demographic, financial, behavioral)\n",
    "- 5 deposit products (Checking dominant at 90%)\n",
    "- 10 loan products (only 8.5% of customers have ANY loan)\n",
    "- Realistic correlations between products"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "def generate_banking_data(n_samples: int) -> pd.DataFrame:\n",
    "    \"\"\"\n",
    "    Generate realistic banking customer data\n",
    "    \"\"\"\n",
    "    print(f\"Generating {n_samples:,} customer records...\")\n",
    "    np.random.seed(42)\n",
    "    \n",
    "    # Customer features\n",
    "    customer_segment = np.random.choice(['SME', 'Corporate', 'Enterprise', 'StartUp'], \n",
    "                                       n_samples, p=[0.60, 0.25, 0.10, 0.05])\n",
    "    industry = np.random.choice([\n",
    "        'Manufacturing', 'Technology', 'Retail', 'Healthcare',\n",
    "        'Finance', 'Education', 'Real Estate', 'Services'\n",
    "    ], n_samples)\n",
    "    region = np.random.choice(['North', 'South', 'East', 'West', 'Central'], n_samples)\n",
    "    business_age = np.random.choice(['0-2', '3-5', '6-10', '11-20', '20+'], \n",
    "                                   n_samples, p=[0.15, 0.25, 0.30, 0.20, 0.10])\n",
    "    credit_rating = np.random.choice(['AAA', 'AA', 'A', 'BBB', 'BB', 'B'], \n",
    "                                    n_samples, p=[0.05, 0.15, 0.30, 0.30, 0.15, 0.05])\n",
    "    legal_structure = np.random.choice(['Pvt Ltd', 'Public Ltd', 'Partnership', 'Sole Proprietor'], n_samples)\n",
    "    \n",
    "    # Numerical features\n",
    "    annual_revenue = np.random.lognormal(14, 2.5, n_samples)\n",
    "    employee_count = np.random.randint(1, 5000, n_samples)\n",
    "    avg_monthly_balance = np.random.lognormal(11, 2.0, n_samples)\n",
    "    transaction_frequency = np.random.poisson(30, n_samples)\n",
    "    debt_to_equity = np.random.uniform(0.1, 4.0, n_samples)\n",
    "    relationship_tenure = np.random.randint(0, 25, n_samples)\n",
    "    digital_engagement = np.random.uniform(0, 100, n_samples)\n",
    "    cash_flow = np.random.lognormal(13, 1.8, n_samples)\n",
    "    collateral_value = np.random.lognormal(14, 2.2, n_samples)\n",
    "    \n",
    "    # Build DataFrame\n",
    "    feature_dict = {\n",
    "        'customer_id': range(n_samples),\n",
    "        'customer_segment': customer_segment,\n",
    "        'industry': industry,\n",
    "        'region': region,\n",
    "        'business_age': business_age,\n",
    "        'credit_rating': credit_rating,\n",
    "        'legal_structure': legal_structure,\n",
    "        'annual_revenue': annual_revenue,\n",
    "        'employee_count': employee_count,\n",
    "        'avg_monthly_balance': avg_monthly_balance,\n",
    "        'transaction_frequency': transaction_frequency,\n",
    "        'debt_to_equity': debt_to_equity,\n",
    "        'relationship_tenure': relationship_tenure,\n",
    "        'digital_engagement': digital_engagement,\n",
    "        'cash_flow': cash_flow,\n",
    "        'collateral_value': collateral_value,\n",
    "    }\n",
    "    \n",
    "    # Add 65 more features to reach 80+\n",
    "    for i in range(65):\n",
    "        feature_dict[f'feature_{i+1}'] = np.random.randn(n_samples)\n",
    "    \n",
    "    df = pd.DataFrame(feature_dict)\n",
    "    \n",
    "    # Generate DEPOSIT products (correlated)\n",
    "    checking_prob = 0.88 + 0.05 * (df['relationship_tenure'] / 25)\n",
    "    df['Checking'] = (np.random.random(n_samples) < checking_prob).astype(int)\n",
    "    \n",
    "    savings_prob = 0.30 + 0.25 * df['Checking'] + 0.10 * (df['relationship_tenure'] / 25)\n",
    "    df['Savings'] = (np.random.random(n_samples) < savings_prob).astype(int)\n",
    "    \n",
    "    mma_prob = 0.05 + 0.20 * (df['avg_monthly_balance'] / df['avg_monthly_balance'].quantile(0.95)).clip(0, 1)\n",
    "    df['MMA'] = (np.random.random(n_samples) < mma_prob).astype(int)\n",
    "    \n",
    "    cd1_prob = 0.02 + 0.06 * df['Savings'] + 0.04 * (df['relationship_tenure'] / 25)\n",
    "    df['CD_1Year'] = (np.random.random(n_samples) < cd1_prob).astype(int)\n",
    "    \n",
    "    cd_gt_prob = 0.01 + 0.05 * df['CD_1Year'] + 0.03 * (df['relationship_tenure'] > 10).astype(int)\n",
    "    df['CD_GT1Year'] = (np.random.random(n_samples) < cd_gt_prob).astype(int)\n",
    "    \n",
    "    # Generate LOAN products (8.5% have ANY loan)\n",
    "    loan_propensity = (\n",
    "        0.25 * (df['annual_revenue'] / df['annual_revenue'].quantile(0.95)).clip(0, 1) +\n",
    "        0.20 * (1 / (df['debt_to_equity'] + 0.5)).clip(0, 1) +\n",
    "        0.15 * (df['cash_flow'] / df['cash_flow'].quantile(0.90)).clip(0, 1) +\n",
    "        0.15 * (df['relationship_tenure'] / 25) +\n",
    "        0.25 * np.random.random(n_samples)\n",
    "    )\n",
    "    \n",
    "    loan_threshold = np.percentile(loan_propensity, 91.5)  # Top 8.5%\n",
    "    is_loan_eligible = loan_propensity > loan_threshold\n",
    "    \n",
    "    df['Line_of_Credit'] = ((np.random.random(n_samples) < 0.06) & is_loan_eligible).astype(int)\n",
    "    df['Business_Cards'] = ((np.random.random(n_samples) < 0.05) & is_loan_eligible).astype(int)\n",
    "    df['Term_Loan'] = ((np.random.random(n_samples) < 0.045) & is_loan_eligible).astype(int)\n",
    "    df['Working_Capital_Loan'] = ((np.random.random(n_samples) < 0.025) & is_loan_eligible & df['Line_of_Credit']).astype(int)\n",
    "    df['Term_Loan_Equipment'] = ((np.random.random(n_samples) < 0.02) & is_loan_eligible).astype(int)\n",
    "    df['Term_Loan_Real_Estate'] = ((np.random.random(n_samples) < 0.015) & is_loan_eligible).astype(int)\n",
    "    df['Letter_of_Credit'] = ((np.random.random(n_samples) < 0.01) & is_loan_eligible).astype(int)\n",
    "    df['SBA_Loan'] = ((np.random.random(n_samples) < 0.008) & is_loan_eligible).astype(int)\n",
    "    df['Construction_Loan'] = ((np.random.random(n_samples) < 0.005) & is_loan_eligible).astype(int)\n",
    "    df['Bridge_Loan'] = ((np.random.random(n_samples) < 0.003) & is_loan_eligible & df['Term_Loan_Real_Estate']).astype(int)\n",
    "    \n",
    "    print(f\"✓ Data generated: {df.shape}\")\n",
    "    return df\n",
    "\n",
    "# Generate data\n",
    "df = generate_banking_data(CONFIG['data']['total_customers'])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Analyze data distribution\n",
    "deposit_products = CONFIG['products']['deposits']\n",
    "loan_products = CONFIG['products']['loans']\n",
    "\n",
    "print(\"\\n\" + \"=\"*80)\n",
    "print(\"DATA DISTRIBUTION\")\n",
    "print(\"=\"*80)\n",
    "\n",
    "print(\"\\nDEPOSIT PRODUCTS:\")\n",
    "for product in deposit_products:\n",
    "    count = df[product].sum()\n",
    "    pct = count / len(df) * 100\n",
    "    print(f\"  {product:<25} {count:>8,} ({pct:>5.2f}%)\")\n",
    "\n",
    "print(\"\\nLOAN PRODUCTS:\")\n",
    "for product in loan_products:\n",
    "    count = df[product].sum()\n",
    "    pct = count / len(df) * 100\n",
    "    imbalance = len(df) / count if count > 0 else float('inf')\n",
    "    print(f\"  {product:<25} {count:>8,} ({pct:>5.2f}%) | Imbalance: 1:{imbalance:.1f}\")\n",
    "\n",
    "has_any_loan = df[loan_products].sum(axis=1) > 0\n",
    "print(f\"\\nCustomers with ANY loan: {has_any_loan.sum():,} ({has_any_loan.mean():.2%})\")\n",
    "print(f\"Deposit-only customers: {(~has_any_loan).sum():,} ({(~has_any_loan).mean():.2%})\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Visualize product adoption\n",
    "fig, axes = plt.subplots(1, 2, figsize=(16, 6))\n",
    "\n",
    "# Deposit products\n",
    "deposit_counts = [df[p].sum() for p in deposit_products]\n",
    "axes[0].barh(deposit_products, deposit_counts, color='steelblue')\n",
    "axes[0].set_xlabel('Number of Customers')\n",
    "axes[0].set_title('Deposit Product Adoption', fontsize=14, fontweight='bold')\n",
    "axes[0].grid(axis='x', alpha=0.3)\n",
    "\n",
    "# Loan products\n",
    "loan_counts = [df[p].sum() for p in loan_products]\n",
    "axes[1].barh(loan_products, loan_counts, color='coral')\n",
    "axes[1].set_xlabel('Number of Customers')\n",
    "axes[1].set_title('Loan Product Adoption (Severe Imbalance)', fontsize=14, fontweight='bold')\n",
    "axes[1].grid(axis='x', alpha=0.3)\n",
    "\n",
    "plt.tight_layout()\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 3. Data Preprocessing\n",
    "\n",
    "### 3.1 Feature Identification and Preparation"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "class DataPreprocessor:\n",
    "    \"\"\"Handle data preprocessing\"\"\"\n",
    "    \n",
    "    def __init__(self, products: List[str]):\n",
    "        self.products = products\n",
    "        self.scaler = None\n",
    "        self.label_encoders = {}\n",
    "        self.feature_names = None\n",
    "        self.categorical_features = None\n",
    "        self.numerical_features = None\n",
    "    \n",
    "    def identify_features(self, df: pd.DataFrame):\n",
    "        \"\"\"Identify categorical and numerical features\"\"\"\n",
    "        all_products = deposit_products + loan_products\n",
    "        exclude_cols = ['customer_id'] + all_products\n",
    "        feature_cols = [col for col in df.columns if col not in exclude_cols]\n",
    "        \n",
    "        self.categorical_features = df[feature_cols].select_dtypes(include=['object']).columns.tolist()\n",
    "        self.numerical_features = df[feature_cols].select_dtypes(include=[np.number]).columns.tolist()\n",
    "        self.feature_names = feature_cols\n",
    "        \n",
    "        print(f\"Features identified:\")\n",
    "        print(f\"  Total: {len(feature_cols)}\")\n",
    "        print(f\"  Categorical: {len(self.categorical_features)}\")\n",
    "        print(f\"  Numerical: {len(self.numerical_features)}\")\n",
    "    \n",
    "    def encode_and_scale(self, df: pd.DataFrame, is_training: bool = True) -> np.ndarray:\n",
    "        \"\"\"Encode categorical and scale numerical features\"\"\"\n",
    "        X = df[self.feature_names].copy()\n",
    "        \n",
    "        # Encode categorical\n",
    "        for col in self.categorical_features:\n",
    "            if is_training:\n",
    "                le = LabelEncoder()\n",
    "                X[col] = le.fit_transform(X[col].astype(str))\n",
    "                self.label_encoders[col] = le\n",
    "            else:\n",
    "                le = self.label_encoders[col]\n",
    "                X[col] = X[col].astype(str).map(\n",
    "                    lambda x: le.transform([x])[0] if x in le.classes_ else -1\n",
    "                )\n",
    "        \n",
    "        # Scale numerical\n",
    "        if is_training:\n",
    "            self.scaler = StandardScaler()\n",
    "            X[self.numerical_features] = self.scaler.fit_transform(X[self.numerical_features])\n",
    "        else:\n",
    "            X[self.numerical_features] = self.scaler.transform(X[self.numerical_features])\n",
    "        \n",
    "        return X.values.astype(np.float32)\n",
    "    \n",
    "    def extract_targets(self, df: pd.DataFrame) -> np.ndarray:\n",
    "        \"\"\"Extract target variables\"\"\"\n",
    "        return df[self.products].values.astype(np.float32)\n",
    "\n",
    "# Initialize preprocessors for deposit and loan models\n",
    "deposit_preprocessor = DataPreprocessor(deposit_products)\n",
    "loan_preprocessor = DataPreprocessor(loan_products)\n",
    "\n",
    "print(\"\\nDEPOSIT MODEL PREPROCESSING:\")\n",
    "deposit_preprocessor.identify_features(df)\n",
    "\n",
    "print(\"\\nLOAN MODEL PREPROCESSING:\")\n",
    "loan_preprocessor.identify_features(df)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### 3.2 Prepare Deposit Training Data"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "def prepare_deposit_data(df: pd.DataFrame, strategy: str = 'balanced') -> pd.DataFrame:\n",
    "    \"\"\"\n",
    "    Prepare deposit training data\n",
    "    Strategy: 'all' or 'balanced' (undersample checking-only customers)\n",
    "    \"\"\"\n",
    "    print(f\"\\nPreparing deposit data (strategy: {strategy})...\")\n",
    "    \n",
    "    if strategy == 'all':\n",
    "        return df.copy()\n",
    "    \n",
    "    elif strategy == 'balanced':\n",
    "        other_deposits = [p for p in deposit_products if p != 'Checking']\n",
    "        df_temp = df.copy()\n",
    "        df_temp['has_other_deposits'] = df_temp[other_deposits].sum(axis=1) > 0\n",
    "        \n",
    "        multi_product = df_temp[df_temp['has_other_deposits'] == True]\n",
    "        checking_only = df_temp[df_temp['has_other_deposits'] == False]\n",
    "        \n",
    "        print(f\"  Multi-product customers: {len(multi_product):,}\")\n",
    "        print(f\"  Checking-only customers: {len(checking_only):,}\")\n",
    "        \n",
    "        sample_size = min(len(checking_only), len(multi_product) * 2)\n",
    "        checking_sample = checking_only.sample(n=sample_size, random_state=42)\n",
    "        \n",
    "        deposit_df = pd.concat([multi_product, checking_sample], ignore_index=True)\n",
    "        deposit_df = deposit_df.drop('has_other_deposits', axis=1)\n",
    "        \n",
    "        print(f\"  Final deposit training set: {len(deposit_df):,}\")\n",
    "        return deposit_df\n",
    "\n",
    "deposit_df = prepare_deposit_data(df, strategy=CONFIG['training']['deposit']['strategy'])"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### 3.3 Prepare Loan Training Data (with Imbalance Handling)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "def prepare_loan_data(df: pd.DataFrame, strategy: str = 'smote') -> Tuple[pd.DataFrame, str]:\n",
    "    \"\"\"\n",
    "    Prepare loan training data with imbalance handling\n",
    "    Returns: (prepared_df, resampling_strategy_for_training)\n",
    "    \"\"\"\n",
    "    print(f\"\\nPreparing loan data (strategy: {strategy})...\")\n",
    "    \n",
    "    df_temp = df.copy()\n",
    "    df_temp['has_any_loan'] = df_temp[loan_products].sum(axis=1) > 0\n",
    "    \n",
    "    loan_customers = df_temp[df_temp['has_any_loan'] == True]\n",
    "    non_loan_customers = df_temp[df_temp['has_any_loan'] == False]\n",
    "    \n",
    "    print(f\"  Total customers: {len(df_temp):,}\")\n",
    "    print(f\"  Loan customers: {len(loan_customers):,} ({len(loan_customers)/len(df_temp):.2%})\")\n",
    "    print(f\"  Non-loan customers: {len(non_loan_customers):,}\")\n",
    "    \n",
    "    if strategy == 'smote':\n",
    "        # Keep all loan + sample non-loan (will apply SMOTE during training)\n",
    "        sample_size = min(len(non_loan_customers), len(loan_customers) * 3)\n",
    "        non_loan_sample = non_loan_customers.sample(n=sample_size, random_state=42)\n",
    "        loan_df = pd.concat([loan_customers, non_loan_sample], ignore_index=True)\n",
    "        \n",
    "        print(f\"  After sampling: {len(loan_